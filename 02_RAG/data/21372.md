# 구글 사용자 전화번호 무차별 대입 공격(Bruteforcing the phone number of any Google user)


* **구글 계정 찾기** 폼을 우회하여 특정 사용자 이름과 연결된 전화번호가 존재하는지 확인 가능함
* **자바스크립트 비활성화** 환경에서도 봇가드(BotGuard) 토큰을 의도적으로 삽입하여, IP 제한을 우회하는 공격 방식 구현 가능함
* 네덜란드 등 일부 국가에서는 전화번호 포맷 특성상 **1백만 개 미만** 조합이 존재하여 현실적으로 **프록시와 IPv6** 회전을 통해 대규모 대입 가능함
* **구글 계정의 디스플레이 네임**을 Looker Studio를 이용해 피해자 임의 동작 없이 손쉽게 노출 가능함
* 이 취약점은 **구글에 보고 및 패치** 완료되었으며, 실제 공격 체인은 자동화로 매우 빠른 시간 내에 전화번호를 확인 가능함

---

개요
--

이 글은 구글 계정의 전화번호를 무차별 대입(브루트포스) 공격으로 알아내는 방법, 그 과정, 그리고 방어 측의 대응까지 자세히 다루는 실제 사례임. 일반적으로 계정 찾기/복구 폼은 Javascript 환경과 봇 방지 체계를 이용하여 남용을 차단함. 그러나, JS가 꺼진 환경+특정 패턴으로는 이 체계를 우회할 수 있음을 증명하고 있음.

조사 배경 및 방식
----------

* 계정 사용자명을 찾는 구글 폼이 **자바스크립트 없이 동작**하는 점을 발견함
* 폼은 특정 **이름(Display Name)과 연동된 전화번호**의 존재 여부를 HTTP 요청 2개로 확인함
  + 1차 요청 : 전화번호 기반으로 ess 값(세션 토큰) 획득
  + 2차 요청 : ess와 이름(GivenName/FamilyName) 파라미터로 계정 존재 여부 판별
* 계정이 존재하면 `usernamerecovery/challenge` 리다이렉트, 없으면 `noaccountsfound` 리다이렉트로 응답

IP 제한 우회(프록시, IPv6 활용)
----------------------

* 초기에는 **IP별 레이트 리밋과 캡챠**로 무차별 대입이 불가했음
* 네덜란드 모바일 번호의 경우 100만개 조합(앞자리가 정해져 있음)으로 프록시 사용 시 현실적이고,
* AWS/Vultr 등 클라우드의 **/64 IPv6 블록**을 활용해 요청마다 다른 주소로 회전 가능, 서버도 IPv6 지원함

BotGuard 토큰 우회
--------------

* JS 폼에서는 **봇가드(BotGuard) 토큰**이 필요함
* No-JS 폼에서 `bgresponse=js_disabled` 파라미터 대신 JS 폼에서 수집한 토큰을 삽입하면 **불제한 제출** 가능
* 멀티스레드 툴을 제작, 대량 전화번호를 입력해 신속하게 **존재 계정** 탐지 가능

오탐 거르기(필터링)
-----------

* 동일 이름/번호 뒤 2자리 조건으로 여러 명이 걸릴 가능성 있음
* 임의의 랜덤 성(last name)을 입력해 다시 테스트함으로써 **오탐 여부**를 자동으로 필터링하는 로직 추가

국가별 전화번호 포맷 및 네임 정보 수집
----------------------

* 복구 폼은 **전화번호 마스킹 포맷**만을 일부 제공함
* 각국 전화번호 패턴(national format)은 구글의 libphonenumbers 정보 조사로 파악 가능
* 피해자의 **디스플레이 네임**은 Looker Studio에서 소유권 변경 기능을 악용해 사용자 동작 없이 확인 가능

최적화 및 자동화
---------

* libphonenumbers로 각국 Prefix/길이/유효성 검증 규칙 딕셔너리 생성
* Go 기반 chromedp로 **BotGuard 토큰 자동 발급 API** 제작, 실제 공격시 자동화 가능

실제 공격 절차
--------

1. Looker Studio 소유권 이전으로 피해자 **이름(디스플레이 네임) 획득**
2. “비밀번호 찾기” 흐름에서 해당 이메일의 **전화번호 일부 마스킹** 수집
3. **gpb 툴**을 통해 이름, 마스킹, 국가 코드 기반으로 대입 공격 실행

시간 및 효율성
--------

* 16 vcpu, 3000 스레드 서버 기준, 1초에 약 4만건 체크
* 국가별 번호 조합/힌트 길이에 따라 미국(20분), 영국(4분), 네덜란드(15초), 싱가포르(5초)면 충분
* 타 서비스에서 풀힌트 제공시(예: PayPal) 시간 더욱 단축

구글 및 패치 타임라인
------------

* 2025.4.14 : 구글에 리포트, 4.25 패널서 감사 표시
* 2025.5 중 : **$5,000 버그바운티** 지급
* 2025.5 : No-JS 폼 점진적 중단 및 대응 조치 적용
* 2025.6.9 : 공식 취약점 공개

결론
--

이 사례는 **계정 복구 흐름, 전화번호 마스킹, 디스플레이 네임 등 여러 정보의 조합**만으로 대규모 자동화 공격이 가능함을 보여줌. 구글은 절차 내 취약점 보완 및 관련 폼을 폐쇄함으로써 대응을 완료함.

문의는 신호/이메일(원문 참고)로 가능함

