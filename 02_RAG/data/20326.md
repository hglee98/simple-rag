# Whenever – Python용 타입 및 DST 안전 날짜 및 시간 처리 기술


* **Whenever**는 Python의 datetime을 개선하여 **DST 안전성**과 **타입 안전성**을 제공하는 라이브러리임
* **Rust**와 **순수 Python**으로 사용 가능하며, **성능**이 뛰어남
* Python 표준 라이브러리와 **Arrow**, **Pendulum**보다 **DST 처리**와 **타입 안전성**에서 우수함
* **나노초 정밀도**와 **최신 GIL 개선 사항**을 지원하며, **Rust 확장**을 통해 성능을 향상시킴
* **MIT 라이선스**로 제공되며, **피드백**을 통해 지속적으로 개선 중임

---

Whenever 소개
-----------

* **Whenever**는 Python의 datetime 모듈의 한계를 극복하기 위해 개발된 라이브러리임
* **DST 안전성**과 **타입 안전성**을 제공하여 코드의 정확성을 높임
* **Rust**와 **순수 Python**으로 구현되어 있으며, 성능이 뛰어남

표준 라이브러리의 한계
------------

* Python의 `datetime`은 **DST**를 항상 고려하지 않음
* **타입 시스템**에서 naive와 aware datetime을 구분할 수 없음

다른 라이브러리와의 비교
-------------

* **Arrow**는 사용자 친화적인 API를 제공하지만, 핵심 문제를 해결하지 못함
* **Pendulum**은 일부 DST 문제를 해결했으나, 성능이 저하되고 유지보수가 부족함

Whenever의 장점
------------

* **DST 안전한 산술 연산**과 **타입 안전한 API** 제공
* **성능**이 뛰어나며, **Rust** 확장을 통해 더욱 향상됨
* **나노초 정밀도**와 **최신 GIL 개선 사항**을 지원함

빠른 시작
-----

* `Instant`, `ZonedDateTime`, `LocalDateTime` 등 명시적인 타입 제공
* **DST 안전한 산술 연산**과 **명시적인 변환** 가능
* **ISO8601**, **RFC3339**, **RFC2822** 형식의 포맷팅 및 파싱 지원

로드맵
---

* **0.x** 버전: 기능 동등성 확보 및 API 개선
* **1.0** 버전: API 안정성과 하위 호환성 확보

한계
--

* **서기 1년부터 9999년까지**의 그레고리력 지원
* **IANA TZ DB**와 일치하는 **시간대 오프셋** 지원
* **윤초**는 지원하지 않음

버전 관리 및 호환성 정책
--------------

* **Whenever**는 **시맨틱 버전 관리**를 따름
* **1.0** 버전 전까지 API 변경 가능성 있음

라이선스
----

* **MIT 라이선스**로 제공되며, **Rust** 의존성은 유사한 허가 라이선스 사용

감사의 글
-----

* **Temporal**, **Noda Time**, **Joda Time** 프로젝트에서 영감을 받음
* **Ruff 프로젝트**의 벤치마크 비교 그래프를 기반으로 함
