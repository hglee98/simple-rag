# 에이전틱 코딩 추천사항


* **Agentic coding**에 대한 실사용 사례 공유
* **Claude Code Sonnet 모델**을 주로 사용하며, IDE 통합보다는 전체 작업을 AI에게 위임하는 방식을 선호함
* **Go 언어**는 에이전트 친화적인 구조와 생태계 안정성 덕분에 새로운 백엔드 프로젝트에 특히 추천됨
* **속도와 단순성**이 에이전틱 코딩의 핵심이며, 테스트 캐시나 간단한 툴 체계가 중요함
* **코드는 단순하고 병렬처리 가능하게 구성**해야 하며, 에이전트의 성능을 극대화하려면 리팩터링 시점 선정이 매우 중요함

---

Preface
-------

* 최근 에이전틱 코딩 경험을 공유하는 개발자들이 급증함
* 나는 현재 Claude Code Sonnet 모델을 Max 요금제($100/월)로 사용함
* IDE의 비중이 줄었고, 대신 Vim을 다시 사용하게 되었으며, Claude에게 작업을 맡기고 결과만 확인하는 식의 흐름을 사용함
* 혁신 속도가 매우 빨라 포스팅 내용이 빠르게 낡을 수 있기 때문에, 오래 유지될 개념에 초점을 맞춤

The Basics
----------

* `claude --dangerously-skip-permissions` 명령어를 `claude-yolo`로 alias 설정해 **모든 권한 제한을 제거**함
  + 이는 dev 환경을 Docker로 안전하게 격리하여 관리할 수 있음
* Claude는 대부분의 기본 툴을 잘 다루기 때문에 MCP(Multi Capability Protocol)는 **특수한 경우에만 사용**함
  + 예: playwright-mcp를 통한 브라우저 자동화
* 직접 만든 툴은 일반적인 스크립트로 구성하며 가능한 한 **단순한 툴 구성 유지**

Choice Of Language
------------------

* 다양한 언어로 에이전틱 코딩을 실험한 결과, 새로운 백엔드 프로젝트에는 **Go가 가장 이상적임**
  + **Context 시스템**: 코드 전체에 명확히 흐르는 데이터 구조 제공, 에이전트에게 명시적 전달 방식이 간편함
  + **테스트 캐시**: Rust 등 타 언어 대비 테스트 실행과 캐시가 단순, 에이전트의 코드-테스트 루프가 효율적임
  + **단순함**: Go 자체의 단순성이 에이전트에게도 유리하게 작용함
  + **구조적 인터페이스**: 타입에 메서드만 맞으면 인터페이스로 인식되어 LLM이 쉽게 처리 가능함
  + **낮은 생태계 변화율**: 오래가는 버전과 명시적 변화, 구식 코드 자동 생성을 줄일 수 있음
* **Python은 많은 문제점**을 유발
  + fixture나 async 처리, 느린 실행 등으로 인해 agentic loop에서 효율이 떨어짐
* 프론트엔드는 **Tailwind + React + Tanstack Query/Router + Vite**
  + Tanstack Router의 파일명에 포함된 `$` 기호는 에이전트를 혼동시켜 문제 발생

Tools, Tools, Tools
-------------------

* 툴의 기준은 다음과 같음
  + **빠를 것**
  + **친절한 에러 메시지 제공**
  + **LLM이 잘못 사용할 경우에도 안정적으로 동작할 것**
  + **관찰 가능하고 디버깅이 쉬울 것**
* Makefile 기반으로 `make dev`, `make tail-log` 등 명령어 제공
  + 실행 상태 중복 방지를 위해 **shoreman 포크 버전으로 pid 관리**
  + 로그는 stdout과 파일에 모두 기록해 **에이전트가 직접 로그에서 정보 추출 가능**
* 예: 이메일 인증 링크도 로그에 기록되도록 설정하여 **브라우저 자동화로 이메일 인증 절차 수행 가능**

It's All About Speed
--------------------

* 에이전틱 코딩의 최대 비효율은 추론 비용과 비효율적인 툴 사용
* **빠른 툴 응답 속도**가 생산성의 핵심
* 에이전트가 자체적으로 임시 도구를 만들고 사용할 경우, 빠른 실행/컴파일 속도가 업무 효율을 크게 향상시킴
* 느린 환경에서는 동적 모듈 로딩 등의 대안(예: Sentry용 파일 모듈 감시 및 자동 실행) 활용이 유리함
* **로그는 간결하고 명확하게** 조절하여 토큰 소모 및 속도를 최적화해야 하며, 필요시 LLM이 로그 수준을 조절할 수 있는 인터페이스 제공이 도움이 됨
* 코드 생성 단계에서부터 유의미한 로그/옵저버빌리티가 나오도록 설계하는 것이 중요함

Stability and Copy/Paste
------------------------

* 에코시스템의 안정성은 **코드 재사용성과 에이전트의 혼동 방지**에 매우 중요
  + Go와 Flask 같은 변동폭이 적고 예측 가능한 언어/프레임워크 사용 권장
* **라이브러리 자동 업그레이드에 주의**, 에이전트가 남긴 주석이나 코드 흐름이 깨질 수 있음
* 가능하면 **직접 코드 작성 → 의존성 최소화** 전략 권장

Write Simple Code
-----------------

* 에이전트는 **단순하고 명시적인 코드**에 더 잘 대응함
* 권장 방침
  + **설명적이며 긴 함수명**의 함수 사용 선호, 클래스보다는 함수 위주 작성
  + 상속 및 복잡한 트릭 회피
  + **순수 SQL** 사용 추천; 에이전트가 SQL 실력에 능숙하며, 로그와 비교 및 추적이 쉬움
  + **명확한 권한 체크**는 코드 상에서 직관적으로 드러나게 구성(별도 파일/설정 분리 금지)

Make It Parallelizable
----------------------

* 개별 에이전트의 처리 속도는 빠르지 않으나, **병렬 처리**를 통해 전체 효율을 높일 수 있음
  + 예: 파일 시스템을 기준으로 체크아웃 복사
  + Redis나 DB 등 공유 자원 분리 방법 고민 필요
  + 예시 툴: [container-use](https://github.com/dagger/container-use)를 이용한 Docker 기반 세션 분리
* **CI 기반 병렬 작업**, Cursor의 background agent 등도 주목할 도구

Learn To Refactor
-----------------

* agentic 방식은 **적절한 시점의 리팩터링**이 중요
  + 복잡성이 높아지면 agent가 코드를 제대로 다루지 못함
  + 예: Tailwind class가 50개 파일에 흩어지기 전에 **컴포넌트 라이브러리화**
* 너무 이른 혹은 너무 늦은 리팩토링 모두 비효율적이므로, 적절한 타이밍에 구조 개선 지시 필요

What Next?
----------

* agentic coding은 빠르게 진화하고 있으며, **핵심 원칙은 ‘단순함, 안정성, 가시성, 병렬성’**
  + 도구와 방법론은 변해도 이 원칙은 유효함
* **생산성 향상뿐 아니라 더 나은 코드 품질 추구**가 목표
* 에이전트가 작성하는 코드의 품질은 몇 달 전보다 현저히 개선됨
* **유연하게 변화에 대응하며 코딩 경험을 확장할 것**
