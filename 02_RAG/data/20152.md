# AI 시대의 시니어 개발자 역량 : 더 나은 결과를 위한 경험 활용


* 최근 몇 달 동안 개인 프로젝트와 직장 업무 모두에서 **AI 기반 코딩 도구**를 실험적으로 사용해봄
* 결과는 매우 긍정적이었으며, **개발 시간 단축과 결과물의 품질 향상** 모두를 경험함
* 반면, 일부 개발자들은 AI 도구가 잘 작동하지 않는다는 **부정적 피드백**을 공유하기도 함
* 이 경험을 통해, AI를 활용한 소프트웨어 개발이 **생산성 면에서 다음 단계로의 도약 가능성**을 가진다고 확신하게 됨
* 단, 무비판적인 수용이 아닌 **올바른 관점과 균형 잡힌 접근 방식**이 필요함
* 이 글을 통해 직접 경험하고 발견한 베스트 프랙티스를 공유하여  
  **AI 도구의 현명한 도입을 넓은 개발 커뮤니티에 조금이라도 앞당기고자 함**

현재 AI 코딩 도구의 활용 현황
------------------

* Twitter에서 관찰한 바로는, **비전문 개발자들** 사이에서 AI 코딩 도구가 큰 인기를 끌고 있음
  + 이들은 AI를 통해 **새로운 프로젝트에 도전**하고, 즐겁게 개발을 배우는 중
* 이러한 흐름은 긍정적이며, 새로운 사용자층에게 **기술의 진입 장벽을 낮추는 데 기여**함
* 그러나 이는 **AI 도구의 가능성을 보여주는 하나의 측면일 뿐**이며,
  + 시니어 개발자처럼 **전문적인 문맥에서도 AI는 큰 가치를 제공할 수 있음**

시니어 개발자의 강점
-----------

* 아직 발전 초기 단계이지만, 현재까지의 결론은 다음과 같음:
  + **시니어 개발자는 AI 도구를 가장 효과적으로 활용할 수 있는 위치에 있음**
  + 단순히 도움을 받는 수준이 아니라, **최적화된 활용이 가능**함
* 핵심은 다음과 같음:
  > **AI 시대에 다소 구식처럼 보일 수 있는 개발 경험과 프로젝트 운영 노하우야말로,  
  > 이 도구들을 가장 잘 활용할 수 있는 기반임**
* LLM 기반의 프로그래밍 에이전트를 비유하자면,
  + **프로그래밍 지식은 매우 풍부한 시니어지만, 현재 문맥에서는 설계 이해가 부족한 주니어**에 가까움
* 그래서 이들에게 실질적인 업무를 맡기려면,
  + **전략적인 준비와 안내가 필수적**임
  + 이 역할을 수행할 수 있는 최적의 인물이 바로 시니어 개발자임
* 결론적으로, 최첨단 기술인 AI 도구조차 **전통적인 개발 관행과 경험을 기반으로 할 때 가장 효과적으로 활용 가능**함

성공적인 AI 코딩 세션을 위한 세 가지 핵심 요소
----------------------------

* AI와 협업하여 좋은 결과를 얻기 위해 다음 **세 가지 요소**가 중요함:
  + **정교한 요구사항 문서화 (Well-structured Requirements)**
  + **도구 기반의 품질 가드레일 (Tool-based Guard Rails)**
  + **파일 기반 키프레임 기법 (File-based Keyframing)**
* 본격적인 설명에 앞서, AI를 활용한 실전 프로젝트 사례들을 소개함
  + **Green-field 프로젝트**: 처음부터 새로 만드는 프로젝트
  + **Brown-field 프로젝트**: 기존 코드베이스 위에 새로운 기능을 추가하는 프로젝트
* 두 경우 모두 AI가 **전체 구현을 거의 전적으로 담당**한 사례에 집중함
  + 단순히 자동완성 보조나 대화형 도우미로서의 AI가 아닌,  
    **에이전트 모드에서 실제 작업을 수행하는 방식**에 초점을 맞춤
* 사용한 도구는 [Cursor](https://www.cursor.com/)이며,
  + Anthropic의 Claude Sonnet 3.7 모델 기반
  + 전체 프로젝트 파일을 직접 수정하고, 관련 명령어도 실행 가능한 기능을 제공함

예제 1: Platform Problem Monitoring (Green-field 프로젝트)
----------------------------------------------------

* Cursor와 Claude를 활용하여 **신규 애플리케이션**인 **Platform Problem Monitoring**을 구현함
  + 소스코드: [GitHub 링크](https://github.com/dx-tooling/platform-problem-monitoring-core)
* 이 앱은 매시간 ELK의 Elasticsearch 서버에 접속해 에러 메시지를 수집하고,  
  웹 플랫폼의 현재 문제 상태를 요약한 **형식화된 이메일 리포트**를 발송함
* 전체 구현은 AI가 수행했으며, **직접 작성한 코드는 없음**
* 저자는 Python 언어에 익숙하지 않지만,
  + **아키텍처, 운영, 베스트 프랙티스에 대한 폭넓은 이해** 덕분에 원활한 진행 가능
  + 이 프로젝트는 **익숙하지 않은 기술 스택에서 AI가 얼마나 도움될 수 있는지 실험**하는 기회였음

> **참고: 코드 품질 이슈**  
> HackerNews 토론에서 로깅 설정, 커스텀 설정 파싱, 레이스 컨디션 등의 코드 품질 문제가 지적되었음  
> 해당 프로젝트는 프로덕션 코드보다는 빠른 프로토타입 제작이 목표였으며,  
> 장기 유지보수나 언어 관례보다는 **기능 구현**에 집중함

예제 2: Process Management UI Integration (Brown-field 프로젝트)
----------------------------------------------------------

* 기존 PHP/Symfony 기반의 레거시 백엔드 기능에 UI를 통합한 사례
* 백엔드는 cron 기반의 CLI 명령어로 운영되었으며, UI가 존재하지 않았음
* 이 기능을 최신 Symfony 애플리케이션에 통합하려고 함
  + 최신 코드베이스, 테스트 체계, 스타일가이드가 존재하는 **UI 친화적 구조** 활용
* 주요 작업 내용:
  + HTTP API를 통한 레거시 시스템과의 통신
  + 시스템 간 데이터 전송 구현
  + UI 디자인 시스템에 맞춘 화면 구성
  + 공유 Symfony 번들 내에 API 클라이언트 구현
* **키프레임 파일**을 제외하고, 전체 구현을 **AI가 자동 수행**함

두 프로젝트에서 얻은 핵심 인사이트
-------------------

1. **Green-field 프로젝트**: 익숙하지 않은 기술 스택에서도 AI의 도움으로 기능적 앱 구현이 가능
2. **Brown-field 프로젝트**: UI 구현이 익숙하지 않은 작업임에도 불구하고, **AI 덕분에 빠르게 기능 완성**

* 이 두 가지 사례를 통해, AI 도구가 **개인 생산성과 팀 전체의 워크플로우에 실질적인 변화를 줄 수 있음**을 체감함
* 그러나 AI가 큰 시간을 절약해주기 위해서는 초기 **셋업 투자와 전략적인 접근**이 필요함
  + 마치 유능한 주니어 개발자를 잘 이끌어주는 것과 같은 방식으로 운영해야 최상의 결과 도출 가능

정교한 요구사항 작성의 중요성
----------------

* 성공적인 AI 코딩 세션의 핵심은 **체계적이고 포괄적인 요구사항 문서**임
* 실제 프로젝트인 *Platform Problem Monitoring*에서는 세션 시작 전에 [REQUIREMENTS.md](https://github.com/dx-tooling/platform-problem-monitoring-core/blob/main/docs/REQUIREMENTS.md) 문서를 작성함
* 해당 문서는 총 371줄로 구성되어 있으며, 다음과 같은 계층 구조를 따름
  + 최상위: 핵심 요구사항을 한 줄로 요약
  + 상위 수준: 사용 사례 및 개발 동기
  + 중간 수준: 프로세스 및 작동 방식
  + 중간 수준: 아키텍처, 기술 스택, 제약 조건
  + 하위 수준: 구체적인 작업 단계를 입력/출력/부작용 기준으로 상세 정리
* 이처럼 체계화된 문서는 AI에게도 명확한 프레임워크를 제공하여 정확한 결과를 유도함
* 문서 작성에는 시간과 노력이 들지만, **성공적인 구현을 위한 필수 투자**임
* 소프트웨어 개발 격언 중 하나:
  > **“6주간의 구현은 2시간의 계획을 아낀다”**

  + 풍자적 표현이지만, 구현 단계에서의 비효율은 계획 부족에서 비롯된다는 진실을 담고 있음
* 그래서 프로젝트는 항상 **키보드가 아닌 화이트보드에서 시작**해야 하며, 이 원칙은 AI와 협업할 때도 똑같이 적용됨
* 실전에서는 Cursor 세션을 다음과 같은 단계로 시작함:
  1. AI가 요구사항을 자체적으로 요약하게 함
  2. 실행 계획을 생성하게 함
  3. 불명확한 부분을 질문하도록 유도함
* 이 검증 단계 이후에야 AI를 “Agent” 모드로 전환하여 구현을 시작함

도구 기반의 품질 가드레일 설정
-----------------

* 요구사항 문서가 **목적지**를 정의한다면, 품질 가드레일은 **그 목적지까지의 최단 경로를 유지**해 줌
* 개발 중 실시간 피드백 시스템의 중요성과 마찬가지로, **정적 분석 도구**는 AI에게도 큰 도움이 됨
* 예를 들어, 런칭 후 고객 문의로 널 체크 누락을 발견하는 것보다 개발 단계에서 사전에 감지하는 것이 훨씬 효율적임
* 따라서 AI 코딩 세션 시작 전에 다음과 같은 **품질 보장 도구들을 반드시 세팅**함
  + [Makefile](https://github.com/dx-tooling/platform-problem-monitoring-core/blob/main/Makefile) 예시 기준:
    - `black`, `isort`: 코드 포맷팅
    - `ruff`: 린팅
    - `mypy`: 타입 검사
    - `bandit`: 보안 분석
    - 테스트 스위트 전반
* Claude 기반의 AI 에이전트는 이 도구들을 인식하고 활용할 수 있음
  + 예: 타입 검사에 실패하면, AI가 스스로 코드를 수정하여 통과되도록 조정함
* 기능적 검증을 위해 **curl 명령어로 API 테스트 요청**도 제공함
  + AI가 직접 엔드포인트를 호출하고, 응답을 확인하며 코드를 개선하는 과정이 인상적임
* 이처럼 도구 기반의 가드레일은 **AI가 신뢰 가능한 결과를 낼 수 있도록 보조하는 필수 구성요소**임

파일 기반의 키프레임 기법
--------------

* AI는 창의적인 구현에는 강하지만, 코드 구조나 파일 구성에 대해서는 방향성이 부족할 수 있음
  + 이를 보완하기 위해 사용하는 전략이 **파일 기반 키프레임(file-based keyframing)** 임
* 이 기법은 애니메이션 제작에서의 키프레임 방식에서 영감을 얻음:
  + 숙련된 애니메이터가 **중요 장면(키프레임)** 을 먼저 만들고, 나머지는 보조 인력이 채워 넣는 방식
  + 품질을 유지하면서 작업 효율을 높일 수 있음
* 실제 AI 코딩 프로젝트에서는 구현 전 미리 **빈 껍데기 파일(stub files)** 을 생성해 둠
  + 예: API 엔드포인트, API 클라이언트, 컨트롤러 클래스, Twig 템플릿 등
* 이러한 키프레임 파일은 AI에게 다음과 같은 **중요한 문맥 정보를 제공**함
  + 프로젝트의 파일 구성 방식
  + 네임스페이스 구조
  + 명명 규칙
  + 일관된 코드 패턴
* 프롬프트로 모든 구조를 설명하기보다, 코드베이스 자체에 힌트를 제공함으로써 AI의 추론 정확도를 높일 수 있음
* 이 접근 방식은 AI 시대에도 여전히 중요한 **"이름 짓기"** 의 원칙을 강조함
  + AI는 언어를 기반으로 동작하기 때문에, **의도와 의미가 담긴 텍스트**는 더 나은 결과를 이끌어냄

실제 사례로 보는 통합 적용 : 구독 계약 대시보드 UI 구현
----------------------------------

* 앞서 설명한 세 가지 핵심 원칙을 하나의 프로젝트에 통합 적용한 실전 예제를 소개함:
  + **정교한 요구사항 문서화**
  + **도구 기반의 품질 가드레일**
  + **파일 기반의 키프레임 기법**
* 프로젝트 개요
  -------

  + 목표: 플랫폼 내 구독 계약 정보를 **표 형식으로 시각화**하는 **읽기 전용 웹 UI 대시보드** 구현
  + 대상: 다중 코드베이스(monorepo) 환경
    - `backend-app`: Symfony 5 애플리케이션, 데이터 보유
    - `janus-christophorus`: Symfony 7 애플리케이션, UI 제공
    - `janus-shared-bundle`: API 클라이언트 구현 포함
    - `janus-webui-bundle`: 스타일가이드, Tailwind 설정, Twig 템플릿 포함
* 요구사항 구조
  -------

  + API를 통해 백엔드 데이터를 읽고, 프론트엔드 UI에서 표시
  + 실제 API 엔드포인트 외에도 **데모 모드 지원** (테스트용 가짜 데이터 제공)
  + UI는 스타일가이드와 일관되도록 구현
  + 각 계층은 다음과 같은 구성요소로 구현됨:
    - API 엔드포인트
    - API 클라이언트
    - Presentation 레이어 서비스 클래스
    - 컨트롤러 및 Twig 템플릿
* AI 세션을 위한 사전 작업
  ---------------

  + 모든 코드베이스에 **파일 기반 키프레임** 방식으로 빈 파일들을 미리 생성
  + 기존의 스타일가이드, 네비게이션 서비스, 유사 기능 등을 **AI의 참고 자료로 제공**
  + 각 코드베이스에서 **품질 도구(PHPStan 등)** 실행 가능
    - 예: `.dxcli/dxcli.sh quality` 스크립트 사용
* 통합된 원칙의 활용 방식
  -------------

  + **요구사항 정리**: 프롬프트에 상세한 요구와 시스템 구조를 설명
  + **가드레일 제공**: 코드 검사 도구 사용 안내 포함
  + **키프레임 제공**: 구현 대상 파일들을 미리 만들어 AI가 정확한 위치와 문맥에 코드 작성 가능
* 주요 목표
  -----

  + 빠르게 **계약 정보를 전체적으로 파악할 수 있는 UI 제공**
  + 실제 구현에서 AI가 질문하고 계획을 세울 수 있도록 **명확한 구조와 힌트 제공**
* 이 예제는 AI 도구와 인간 경험이 협업할 때 얼마나 강력한 시너지를 낼 수 있는지를 잘 보여줌

결론: AI 도구 + 인간의 경험 = 최고의 조합
---------------------------

* **정교한 요구사항**, **도구 기반의 가드레일**, **파일 기반 키프레임**을 제공함으로써  
  AI의 강력한 기능을 활용하면서도 코드 품질과 아키텍처의 일관성을 유지할 수 있음
* 이러한 전통적인 개발 관행은 AI 시대에도 여전히 유효하며,  
  오히려 **시니어 개발자의 경험과 통찰력**을 통해 더 큰 효과를 발휘함
* 결국, AI는 도구일 뿐이며  
  **이를 올바르게 활용할 수 있는 인간의 경험과 기술이 그 어느 때보다 중요한 시대**임
