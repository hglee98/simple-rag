# 왜 F#인가?


* F#은 .NET을 타깃으로 하는 **ML 계열 함수형 언어**이며, Microsoft에서 개발. 주로 객체지향인 C#에 비해 **F#은 함수형 프로그래밍 패러다임**에 집중함
* 이 글은 F#의 언어 특징, 생태계, 문서화 상태, 개발 도구, 활용 사례, 커뮤니티 현황, F# vs. OCaml 등을 정리

F#이란?
-----

* **F#은 간결하고 견고하며 성능 좋은 코드**를 작성하기 위한 범용 프로그래밍 언어
* 복잡한 문법에 신경 쓰지 않고, **문제 해결 자체에 집중할 수 있도록 설계됨**
* 오픈소스, 크로스 플랫폼, .NET과의 높은 호환성을 가짐
* 특징
  --

  + 가벼운 문법과 기본 불변성
  + 타입 추론 및 일반화
  + 일급 함수, 강력한 자료형, 패턴 매칭
  + 비동기 프로그래밍(Async) 지원
  + 유명한 \*\*파이프라인 연산자 (`|>`)\*\*의 원조 언어
* 간단한 예제 코드
  ---------

  ```
  open System  
  let names = [ "Peter"; "Julia"; "Xi" ]  
  let getGreeting name = $"Hello, {name}"  
  names |> List.map getGreeting |> List.iter (printfn "%s")  

  ```
* F#은 2005년 Microsoft Research에서 Don Syme이 개발한 언어로 시작됨
  + \*\*OCaml을 .NET 플랫폼에 이식하는 연구 프로젝트(Caml.NET)\*\*에서 출발
  + 이후 2010년부터 정식 제품으로 편입되었고, 2024년에는 F# 9.0이 출시됨
  + 2025년 현재는 20주년을 맞이한 성숙한 언어로 자리매김
* F#을 실험하게 된 주요 이유
  + .NET이 오픈소스 및 크로스 플랫폼으로 진화한 점 확인
  + OCaml 대비 장단점 비교
  + Rider, Ionide 등 툴링에 대한 긍정적 평가
  + 단순한 언어 탐험에 대한 흥미

언어로서의 F#
--------

* F#은 **ML 계열 함수형 언어**로, OCaml 사용자에게는 익숙한 문법을 가짐
* Haskell이나 Lisp 사용 경험이 있는 개발자도 쉽게 적응 가능함
* 공백 기반 문법 구조로, Python처럼 **들여쓰기가 문법적으로 중요**함
* 초보자도 빠르게 기본 문법을 익힐 수 있도록 설계됨
* 언어 특징 요약
  --------

  + **함수 정의와 적용**이 간결하며 자연스러운 방식으로 표현 가능함
  + **조건문, 반복문, 튜플, 리스트 처리** 등이 함수형 스타일로 깔끔하게 사용 가능함
  + **레코드, 열거형(Discriminated Union), 패턴 매칭**을 통해 복잡한 데이터 구조를 간결하게 다룸
  + 파이프라인 연산자(`|>`)를 통해 데이터 흐름을 **함수 연결처럼 시각적으로 명확하게 구성**할 수 있음
  + **F#은 ad-hoc 스크립트 작성**에 매우 적합하며, `.fsx` 파일로 작성 후 `dotnet fsi`로 바로 실행 가능함
  + REPL 환경도 제공되어 **탐색적 프로그래밍**에 유리함
* 사용자 친화적인 문법
  -----------

  + **한 줄 및 여러 줄 주석**, `mutable` 변수, 리스트 슬라이스 등 실용적인 문법 기능 포함
  + C#과의 높은 호환성 덕분에 .NET API를 쉽게 사용할 수 있음
  + 다양한 타입에 대한 연산자 오버로드도 자연스럽게 지원함
  + `printfn`으로 다양한 타입을 손쉽게 출력할 수 있어 디버깅과 로깅에 유용함
* 비동기 프로그래밍의 선구자
  --------------

  + **`async/await` 패턴의 원조는 F# 2.0**으로, 이후 C#과 JavaScript 등 여러 언어에 영향을 줌
  + F#은 비동기 프로그래밍을 **콜백 없이도 직관적으로 구현**할 수 있는 구조를 제공함
  + 코드 흐름이 동기식처럼 읽히지만, 실제로는 비동기로 동작함
* Microsoft의 투자와 언어 발전
  --------------------

  + Microsoft는 오랜 기간 F#에 제한적인 인력을 할당했으나, **2022년 프라하에 전담 팀을 구성하며 본격 투자 시작**
  + F# 8.0, 9.0의 릴리스를 통해 **언어 및 툴링이 빠르게 개선되고 있음**
  + Microsoft의 내부 관심이 늘어나면서 **미래 발전 가능성**도 기대할 수 있음

> F#은 배우기 쉬우면서도 강력한 타입 시스템과 함수형 프로그래밍 패러다임을 갖춘 실용적인 언어이며, 특히 **.NET 기반 프로젝트에서 함수형 접근법을 도입하고 싶은 개발자에게 매우 매력적인 선택지**임

생태계(Ecosystem)
--------------

* F#은 상대적으로 짧은 기간 동안 사용해 본 결과, **순수 F# 전용 라이브러리나 프레임워크는 많지 않음**
* 대부분의 사용자들은 **.NET의 기본 API와 C# 위주로 설계된 서드파티 라이브러리**에 의존하고 있음
* 이는 Scala, Clojure, Groovy 같은 \*\*호스트 언어(hosted language)\*\*에서는 흔히 볼 수 있는 현상임
* 웹 개발용 주요 라이브러리
  --------------

  + **Giraffe**: ASP.NET Core 기반의 경량 웹 프레임워크로, 함수형 스타일을 지향함
  + **Suave**: 라우팅과 작업 구성을 위한 컴비네이터 스타일의 간단한 웹 서버 프레임워크
  + **Saturn**: Giraffe 위에 구축된 MVC 스타일 프레임워크, Ruby on Rails 및 Phoenix에서 영감받음
  + **Bolero**: WebAssembly와 Blazor 기반의 클라이언트 애플리케이션 개발 프레임워크
  + **Fable**: F#을 JavaScript로 트랜스파일하여 React, Node.js 등의 JS 생태계와 연동 가능하게 함
  + **Elmish**: Fable과 함께 자주 사용되는 MVU(Model-View-Update) 패턴 기반의 UI 프레임워크
  + **SAFE Stack**: Saturn, Fable, Elmish, Azure 등을 조합한 엔드투엔드 함수형 웹 개발 스택
* 데이터 사이언스용 주요 라이브러리
  ------------------

  + **Deedle**: pandas 스타일의 데이터 분석 및 조작 라이브러리
  + **DiffSharp**: 머신러닝과 자동 미분 기능을 제공하는 수학 중심 라이브러리
  + **FsLab**: 시각화, 통계 분석 도구 등을 포함한 데이터 사이언스 통합 툴킷

문서화 상태
------

* 공식 문서는 전반적으로 **잘 정리되어 있고 품질이 높음**
* 일부는 Microsoft Docs에, 일부는 [F# Software Foundation](https://fsharp.org/)에 분산되어 있음
* 문서 구성은 약간 산만할 수 있으나 **언어 스타일 가이드, 디자인 문서, 표준 라이브러리 API**가 매우 유용함
* 추천 문서 링크
  --------

  + [F# 스타일 가이드](https://learn.microsoft.com/en-us/dotnet/fsharp/style-guide/)
  + [F# 디자인(RFC 문서 모음)](https://github.com/fsharp/fslang-design)
  + [F# 표준 라이브러리 API 문서](https://fsharp.github.io/fsharp-core-docs/)
* 커뮤니티 학습 자료
  ----------

  + [F# for Fun and Profit](https://fsharpforfunandprofit.com/): 튜토리얼 및 에세이 모음 (다소 오래됐지만 여전히 유효함)

개발 도구(Dev Tooling)
------------------

* F#의 개발 도구 생태계는 과거에는 **Visual Studio에만 최적화**되어 있었고, 그 외 에디터에 대한 지원은 부족했음
* 다행히도 지난 10년간 도구 환경이 크게 개선되었음
* 기술적 전환점: FSharp.Compiler.Service(FCS)
  -------------------------------------

  + **FCS**는 F# 컴파일러, 편집기 지원 기능, 스크립팅 엔진을 포함한 단일 라이브러리로, 다양한 에디터 및 툴링 환경에서 F#을 사용할 수 있게 함
  + 이로 인해 VS Code, 문서 생성기, 대체 백엔드 등에 F# 지원이 가능해졌고, 생태계 확장을 이끔
  + 대표적인 예로 **Ionide**는 VS Code에서 풍부한 F# 지원을 제공하며, **100만 다운로드 이상 기록**
* 테스트한 에디터들
  ---------

  + **Emacs** (`fsharp-mode`): 기본적인 기능 제공, TreeSitter 미지원, 개발 활동 적음
  + **Zed**: F# 지원은 제한적
  + **Helix**: 기본 지원 있음
  + **VS Code** (Ionide 플러그인): 가장 완성도 높은 환경 중 하나
  + **JetBrains Rider**: 상용 IDE지만 F# 지원이 매우 강력함
  > 대부분의 기능은 F# 언어 서버(`fsautocomplete`) 기반으로 작동하며, **LSP 지원이 좋은 에디터는 모두 사용 가능**
* 아쉬운 점
  -----

  + `fsharp-mode`는 오래된 코드베이스 기반이며 발전이 느림
  + Zed는 기능이 부족
  + VS Code는 일부 기능(예: 선택 영역 확장/축소)이 제대로 동작하지 않음
  + 키바인딩/모달 모델 문제로 인해 VS Code를 불편하게 느끼는 사용자도 존재함
* 코드 포매터 및 린터
  -----------

  + **Fantomas**: F# 공식 코드 포매터로, 대부분의 사용자 및 팀이 사용 중
  + **FSharpLint**: 한때 인기 있었으나 현재는 사실상 중단됨
  + 그러나 **강력한 컴파일러** 덕분에 린터 의존도가 낮음
* 기타 도구
  -----

  + [**Paket**](https://fsprojects.github.io/Paket/): .NET을 위한 의존성 관리자 (`npm`, `pip`, `bundler`와 유사)
  + [**FAKE**](https://fake.build/): 빌드 스크립트를 F#으로 작성할 수 있는 DSL, Ruby의 `rake`와 유사

활용 사례(Use Cases)
----------------

* .NET의 폭넓은 생태계 덕분에 F#은 다양한 분야에서 활용 가능성 존재
* 특히 **타입 프로바이더(Type Providers)** 기능 덕분에 **데이터 분석 및 조작 작업**에 매우 적합함
* 백엔드 서비스, 전체 스택 애플리케이션 개발에도 적절하며, 일부 도구들은 **프론트엔드 개발**까지 가능하게 해줌
* 주요 활용 영역
  --------

  + **데이터 분석**: F#의 타입 프로바이더를 활용해 정적 타입 기반의 데이터 조작 가능
  + **백엔드 서비스**: .NET의 강력한 웹 프레임워크와 함께 F# 사용 가능
  + **프론트엔드 앱**: Fable과 Elmish를 통해 JS 생태계와 통합된 UI 개발 가능
    - `Fable 4`부터는 **TypeScript**, **Rust**, **Python** 등 다양한 언어로도 트랜스파일 가능
* Fable 예시 (간단한 트랜스파일 명령)
  -----------------------

  + 자바스크립트:  
    `dotnet fable`
  + 타입스크립트:  
    `dotnet fable --lang typescript`
  + 파이썬:  
    `dotnet fable --lang python`

커뮤니티 상황
-------

* 전체적으로 커뮤니티는 크지 않으며 **OCaml보다도 작을 수 있음**
* **Reddit**과 **Discord** 채널이 가장 활발한 커뮤니케이션 공간
* **Slack** 커뮤니티도 존재하지만 초대 자동화 시스템 문제로 접근이 어려움
* Microsoft의 커뮤니티 내 역할은 불분명하며, 커뮤니티 주도성이 강한 편
* 커뮤니티에서 운영 중인 주요 리소스
  -------------------

  + [**Amplifying F#**](https://amplifyingfsharp.io/): F# 확산 및 기업 참여 유도
  + [**F# for Fun and Profit**](https://fsharpforfunandprofit.com/): 튜토리얼 및 에세이 아카이브
  + [**F# Lab**](https://fslab.org/): 데이터 과학용 F# 커뮤니티 툴킷
  + [**F# Weekly**](https://sergeytihon.com/category/f-weekly/): 최신 F# 소식 정리 뉴스레터

인기와 현실 (The Popularity Contest)
-------------------------------

* F#은 대부분의 인기 지표(TIOBE, StackOverflow, 구인 공고 등)에서 높은 순위에 있지는 않음
* 하지만 이는 대부분의 **함수형 언어들이 처한 현실**이기도 하며, F#만의 문제는 아님
* 여전히 주류는 아니지만, **Clojure, OCaml, Emacs Lisp**과 같은 다른 함수형 언어들과 비슷한 수준의 사용자층을 가짐
* 왜 F#을 쓸까?
  ---------

  + **취업 가능성 외에도** 프로그래밍 언어를 선택하는 이유는 다양함
    - 재미를 위해 (F#의 F는 “Fun”을 의미한다는 말도 있음)
    - 새로운 패러다임과 아이디어 학습
    - 익숙한 사고방식에서 벗어나 다른 방식으로 사고하는 훈련
* 관련 자료
  -----

  + [F#의 인기 현황에 대한 글](https://medium.com/@lanayx/about-f-popularity-c9b78ed89252)
  + [2024년 기준 F#의 인기 분석](https://hamy.xyz/blog/2024-11_fsharp-popularity)
    - [해당 글의 영상 버전](https://www.youtube.com/watch?v=JioaHcy_QE0&t=1s)도 참고 가능

F# vs OCaml 비교
--------------

> F#의 초기 목적은 OCaml의 장점을 .NET으로, .NET의 장점을 OCaml로 가져오는 것이었음  
> – Don Syme, F#의 창시자

* F#은 OCaml에서 영감을 받아 개발되었으며, 초반에는 `.ml`, `.mli` 파일 확장자도 지원했을 만큼 유사성이 높았음
* 시간이 지나며 점점 독립된 언어로 진화했고, 이제는 각자의 방향으로 발전하고 있음
* F#의 장점
  ------

  + **.NET 플랫폼 기반**
    - 방대한 수의 라이브러리 활용 가능
  + **Microsoft의 지원**
  + **초보자 친화적**
    - 객체지향 언어(C# 등) 사용 경험자에게 익숙한 문법
    - 컴파일러의 오류 메시지가 비교적 명확함
    - 디버깅 경험이 더 직관적
  + **비동기 프로그래밍 지원이 강력함**
  + **OCaml에 없는 기능 제공**
    - 익명 레코드
    - 액티브 패턴
    - 계산 표현식 (computational expressions)
    - 시퀀스 컴프리헨션
    - 타입 프로바이더 (type providers)
    - 단위 계산 (units of measure)
* F#의 단점
  ------

  + **.NET 플랫폼 기반**
    - 언어 설계에서 `.NET`과의 상호 운용을 위한 타협이 많음 (`null` 허용 등)
  + **Microsoft의 소유**
    - 마이크로소프트에 대한 선호도 차이 존재
    - 비교적 적은 리소스가 F#에 배정됨
    - 장기적으로 MS가 F#을 얼마나 지원할지는 불확실함
  + **이름 관련 문제**
    - `PascalCase`, `camelCase` 네이밍 컨벤션이 싫은 사람에게는 불편할 수 있음
    - F#이라는 이름은 검색이나 파일 이름에서 문제를 일으킬 수 있음 (그래서 FSharp으로도 자주 표기됨)
  + **OCaml에 있는 고급 기능 부재**
    - 일급 모듈, 펑터(functor)
    - GADT 지원 부족
  + **마스코트가 없고 낙타도 없음**
* 공통점 및 상호 비교
  -----------

  + 두 언어 모두 JavaScript 런타임 타깃이 가능함
    - F#: [Fable](https://fable.io/)
    - OCaml: js\_of\_ocaml, Melange
  + 현재는 **Fable이 더 성숙한 느낌**이지만, 실사용 경험은 더 필요함
  + **둘 다 강력하지만 니치한 언어**이며, 당분간 폭넓은 대중 언어가 될 가능성은 낮음
  + **F#은 기존 C# 코드베이스에 조금씩 스며들 수 있는 실용성이 있음**
  + 단점 하나는 **F# 프로젝트는 아직도 XML 기반의 프로젝트 파일을 사용**하고, 컴파일 순서를 수동으로 지정해야 함
    - 이는 OCaml의 빌드 시스템인 `Dune`과 비교할 때 번거롭게 느껴질 수 있음
  + 교육적 목적이나 언어 구조 학습에는 OCaml이 적합할 수 있음
  + 실용적인 웹 서비스나 백엔드 개발 목적이라면 F#이 더 나은 선택일 수 있음
  + 특히 `.NET`과 잘 통합되면서도 함수형 스타일을 유지할 수 있는 언어로서 F#은 매우 강력한 도구임

마무리 소감
------

* 글쓴이는 F#을 생각보다 **훨씬 더 재미있고 실용적인 언어**로 느꼈음
  + 과거 Clojure를 처음 접했을 때와 비슷한 느낌을 받았다고 표현함
  + 특히 Clojure가 Java와의 뛰어난 상호운용성 덕분에 **가장 실용적인 Lisp**였던 점을 상기시킴
* 만약 .NET이 처음부터 오픈소스이자 포터블했더라면,
  + **ClojureCLR이 지금보다 더 인기를 끌었을 가능성**
  + **F#의 커뮤니티와 생태계도 더 성장했을 것**이라는 아쉬움을 전함
* F#이 2010년까지 오픈소스가 아니었다는 점도 **초기 채택에 방해가 되었음**

> ".NET과 F# 모두 초기에 오픈소스가 아니었던 것이 가장 큰 실수였으며, 이로 인해 많은 기회를 잃었음" – Don Syme

* OCaml도 배우기 어렵지 않지만, **ML 계열 언어를 처음 배우는 사람에게는 F#이 더 쉬울 수 있음**
  + 프로덕션까지 가는 진입장벽도 더 낮음
* 특히 **.NET 경험이 있는 개발자라면 F#을 반드시 경험해볼 가치**가 있다고 강조함
  + F#은 독립적인 언어로서 훌륭할 뿐만 아니라, .NET의 강력한 생태계를 활용할 수 있는 기회를 제공함
* [Fable](https://fable.io/) 같은 툴을 통해 F# 코드를 JavaScript, Dart, Rust, Python 등으로 트랜스파일링 가능함
* F# 커뮤니티에서는 "F#의 F는 Fun(재미)이다"라는 말이 있음
  + 글쓴이도 직접 써보며 이 말이 사실이라고 느꼈고, **재미있을 뿐 아니라 실용적이기까지 하다**고 강조함
* 마지막으로 "컴파일이 성공하면 대부분 잘 작동한다"는 F#의 안정성과 신뢰성도 언급함

> **In sane type systems we trust!**

