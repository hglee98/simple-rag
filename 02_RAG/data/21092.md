# 알제브라적 이펙트가 필요한 이유


* **알제브라적 이펙트**(effect handlers)는 다양한 언어 기능(예외 처리, 제너레이터, 코루틴 등)을 라이브러리 수준에서 구현할 수 있게 해주는 **유연한 제어 흐름 도구**임
* 함수형 프로그래밍에서 흔한 **컨텍스트 관리, 의존성 주입, 글로발 상태 대체 등**에도 적용 가능함
* **API 설계의 간결성**과 코드 내에서의 상태/환경 전달의 자동화에 기여함
* **함수형 순수성 보장, 리플레이어빌리티, 보안 감사** 등도 지원하는 장점이 있음
* 최근 컴파일러 기술 발전으로 **성능 이슈도 많이 개선**됨

---

알제브라적 이펙트(Algebraic Effects)의 개요
--------------------------------

알제브라적 이펙트(일명 effect handlers)는 최근 각광받는 프로그래밍 언어 기능임. Ante와 여러 연구 언어(Koka, Effekt, Eff, Flix 등)의 핵심 기능 중 하나로 빠르게 확장 추세를 보임. 많은 자료가 이펙트 핸들러의 개념을 설명하지만, 실제로 "왜" 필요한지에 대한 심층적 설명은 부족한 상황임. 이 글은 알제브라적 이펙트의 실질적인 용처와 이점을 최대한 폭넓게 소개함.

### 문법과 의미론 빠른 이해

* 알제브라적 이펙트는 "**재개 가능한 예외**"와 유사한 개념임
* `effect SayMessage`와 같이 이펙트 함수 선언 가능
* `foo () can SayMessage = ...` 처럼, 함수에서 해당 이펙트 사용 가능성 명시
* `handle foo () | say_message () -> ...`로 예외의 try/catch처럼 핸들링 가능

이와 같은 기본 구조를 통해 이펙트 호출 및 제어가 가능함

사용자 정의 제어 흐름 확장
---------------

알제브라적 이펙트의 가장 큰 이유는 한 언어 기능만으로 원래 각각 별도의 언어 기능(제너레이터, 예외, 코루틴, 비동기 등) 필요하던 기능을 **라이브러리로 구현**할 수 있음.

* 함수에 다형적 이펙트 변수 (`can e`)를 두면, 다양한 이펙트를 함수 인자로 전달 및 조합 가능함
* 예시로, `map` 함수는 인자로 받은 함수가 임의의 이펙트 `e`를 쓸 수 있도록 선언, 다양한 효과(출력, 비동기 등)와 자연스럽게 결합 가능함

#### 예외와 제너레이터 구현 예시

* **예외 구현**: 이펙트 발생 후 `resume` 호출 없이 처리하면 예외와 동일하게 동작함
* **제너레이터 구현**: `Yield` 이펙트 정의, 값을 yield할 때마다 외부 핸들러가 개입하여 조건에 따라 흐름 제어 가능, 필터링 등 고급 패턴도 간단한 수준의 코드로 작성 가능함

여러 이펙트를 조합해서 사용할 수 있다는 점도 기존 효과 추상화 기법에 비해 큰 장점임

추상화 계층으로서의 활용
-------------

알제브라적 이펙트는 단순히 코어 프로그래밍 기능 확장 외에도 다양한 비즈니스 애플리케이션 시나리오에서 활용도가 높음

### 의존성 주입 (Dependency Injection)

* 데이터베이스, 출력 등 의존 객체를 이펙트로 추상화하여 **핸들러로 관리 가능**
* 테스트용 목(mock) 객체 대체, 출력 리디렉션 등도 유연하게 구현 가능

### 조건부 로깅 또는 출력 관리

* 로깅 레벨에 따라 로그 메시지 출력 여부를 중앙에서 제어 가능

API 설계 간결화 및 Context 전달 자동화
---------------------------

### 상태(State) 이펙트 활용

* Context 객체 혹은 환경 정보 전달이 필요한 상황에서, 이펙트 기반으로 `get/set`만 사용하도록 구현 시, **명시적 전달 없이 상태 관리 자동화** 가능
* 기존에는 모든 함수에 context를 인자로 넘겨야 하지만, state effect로 이 부분을 은닉 가능

#### 글로벌 객체 대체

* 난수 발생기, 메모리 할당 등 전역 객체로 관리하던 상태도 effect로 추상화해 코드의 명확성, 테스트 편의성, 동시성 지원 측면에서 유리함
* 핸들러만 교체하면 실제 난수 소스를 유연하게 변경 가능

### 직접 스타일(Direct Style) 작성 지원

* 기존에는 옵션 타입, 에러 래핑 등으로 여러 객체를 중첩해서 다뤄야 했음
* 이펙트는 이러한 래핑 없이도 에러나 부수효과 경로를 깨끗하게 표현할 수 있음

순수성 보장과 보안 감사
-------------

### 부작용(부수효과) 명시

* 대부분의 이펙트 핸들러 언어에서는, 부수효과가 발생하는 함수에 반드시 `can IO`, `can Print` 등 효과를 타입 시그니처에 명시함
* 쓰레드 생성, 소프트웨어 트랜잭셔널 메모리(STM) 등에서는 반드시 순수 함수 필요함

#### 로그 리플레이 및 결정적 네트워킹

* 순수성을 기반으로 `record`, `replay`와 같은 핸들러를 만들어 실행 결과를 재현 가능
* **디버깅, 데이터베이스, 게임 네트워크 등**에 결정적 결과 및 롤백 지원 가능

#### Capability-based Security 지원

* 함수 타입 시그니처에 처리하지 않은 모든 이펙트가 노출되어, 외부 라이브러리 보안 감사시 효과적임
* 만약 기존에 부수효과가 없던 함수가 업데이트되어 `can IO`가 붙으면, 이를 호출하는 코드에서 즉시 감지 가능함

다만, 모든 이펙트가 자동으로 전파되기에 무심결에 효과가 처리되는 부작용 발생 가능성도 있음

효율성 관점과 결론
----------

* 예전엔 실행 효율 문제가 약점이었으나, 최근엔 tail-resumptive 효과 등 다수의 경우에서 **최적화가 매우 진전**됨
* 다양한 언어별로 각각 효과적인 컴파일 전략(closure call, evidence passing, 핸들러 특수화 등) 적용됨

알제브라적 이펙트는 미래의 프로그래밍 언어에서 훨씬 더 핵심적인 위치를 차지할 것으로 기대됨.

