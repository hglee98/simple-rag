# 리눅스 SMB 구현에서 o3를 활용해 원격 0-day를 발견함


* **OpenAI o3 모델**을 활용해 리눅스 커널의 SMB 구현에서 **원격 0-day 취약점**(CVE-2025-37899)을 발견한 경험을 공유함
* ksmbd의 코드에 대해 **LLM 분석 능력**을 벤치마킹하는 과정에서, 기존에 수동으로 찾은 취약점을 기준으로 LLM의 성능을 비교 실험함
* 취약점 탐지 과정에서 **함수별로 컨텍스트를 구성하고 적절한 프롬프트**를 제공하여 o3가 취약점을 인식할 수 있도록 설계함
* 실험 결과 **o3는 기존 LLM 대비 2~3배 높은 정확도**로 취약점을 찾아내며, 새로운 형태의 use-after-free 버그도 동시에 자동 발견함
* LLM, 특히 o3와 같은 최신 모델은 **코드 감사와 취약점 연구에 있어 인간 접근 방식과 유사한 유연성·창의성**을 보여주며, 실무 활용 가치가 높아짐

---

서론
--

이 글에서는 OpenAI의 o3 모델을 이용하여 리눅스 커널의 SMB 구현(ksmbd)에서 원격 0-day 취약점을 어떻게 발견했는지 소개함. 단순히 o3 API만 활용했으며 별도의 프레임워크나 도구 없이 실험을 진행함. ksmbd는 리눅스 커널 내에서 SMB3 프로토콜을 구현해 네트워크 파일 공유를 담당하는 서버임. LLM 관련 개발에서 잠시 쉬고자 시작한 취약점 감사를 계기로, o3가 실제 버그를 얼마나 잘 찾을 수 있는지 벤치마크를 실시함. 여기서는 특히, o3가 찾은 제로데이 취약점인 CVE-2025-37899에 초점을 맞춤.

이 취약점은 SMB ‘logoff’ 명령어의 처리과정에서 발생하는 use-after-free 문제임. 이는 서버에 대한 **동시 연결 상황**과 특정 오브젝트를 여러 스레드가 공유하는 방식에 대한 이해를 요구함. o3는 이러한 동시성 이슈와 객체 관리상의 오류를 맥락 속에서 파악해 취약점을 검출함. 이는 LLM이 이런 유형의 취약점을 발견한 최초의 공개 사례임.

주요 메시지는, o3를 통해 LLM의 코드 분석 및 논리 능력이 한 단계 도약했음을 보여주며, 취약점 연구자라면 반드시 이 흐름에 주목해야 함을 강조함. LLM이 전문가를 대체하지는 않으나, 이미 전문가의 **생산성과 효율성을 획기적으로 높여주는 도구**로 발전했음을 시사함. 1만 줄 이하의 코드라면 o3로 대부분의 문제 탐지 및 해결에 실질적인 도움을 받을 수 있음.

CVE-2025-37778을 활용한 o3 벤치마킹
---------------------------

### 벤치마크 배경과 취지

먼저, 직접 수동으로 발견한 취약점인 CVE-2025-37778(이하 kerberos 인증 취약점)을 기준점으로 삼아 o3의 취약점 감지 능력을 평가함. 이는 클라이언트 인증 과정에서 세션 상태가 특정 조건을 만족할 때 use-after-free가 발생하는 문제임.

* 세션 상태가 `SMB2_SESSION_VALID`일 때 유저 객체를 메모리에서 해제
* 이후 인증이 실패하면 유저 객체가 다시 초기화되지 않고, 그 상태로 접근이 가능해져 use-after-free 발생
* 관련 경로 전체를 파악하려면 약 3,300줄의 코드를 따라가야 하므로 적당한 난이도를 가진 벤치마크 과제임

### 분석 컨텍스트 구성

실험에서는 실제 자동화된 취약점 탐지 시스템 관점에서, LLM에 주어질 컨텍스트(코드 영역)를 세심히 구성함. SMB 명령어 핸들러 단위로 주요 함수 및 하위 함수들을 3단계 콜 뎁스까지 포함시켜, 논리적 연관 코드를 모두 입력함(총 3.3k LoC, 약 27k 토큰). 데이터 파싱, 요청 분기, 접속 해제 등 관련 함수도 포함되어야 신뢰성 높은 결과를 얻을 수 있음.

구체적으로 사용한 프롬프트와 입력 자료는 관련 Github 저장소에서 확인 가능함. LLM에게는 아래와 같은 조건을 줌:

* use-after-free 취약점을 탐지하도록 명확히 지시함
* ksmbd의 기본 구조와 위협 모델 간략히 설명
* 허위 양성(False Positive) 방지를 위한 유도 프롬프트 사용

실제 쿼리는 llm 커맨드라인 툴로 반복 실행해 실험 결과를 수집함(N=100).

### 벤치마크 실험 결과

* o3 : 100번 중 8번 kerberos 인증 취약점 탐지, 66번 미탐지(누락), 28번 허위 양성 보고
* Claude Sonnet 3.7 : 3번만 탐지
* Claude Sonnet 3.5 : 100번 모두 탐지 실패

결국 o3는 기존 LLM 대비 2~3배 이상 높은 정확도를 기록함. 또한 실제 o3의 출력은 인간 보안연구자가 작성한 요약 리포트처럼 간결함. 반면 Sonnet 3.7 결과는 과정 중심의 작업로그에 가까운 인상을 주며, 장점도 단점도 공존함.

o3를 통한 실제 0-day (CVE-2025-37899) 발견
-----------------------------------

#### 대규모 코드 입력 환경 실험

kerberos 취약점 외에도, SMB 명령 핸들러 전체(약 9,000줄)를 포함해 o3로 전체적인 취약점 탐지를 시도함. 각종 핸들러, 연결/해제 코드 등 전체를 합쳐 총 약 12k LoC(약 10만 토큰)를 한 번에 입력함. 100번 반복 실행 시, kerberos 인증 취약점은 오직 1회만 탐지되어 성능 저하가 명확하나, 주요 목적은 더 많은 코드 범위에서의 LLM 활용성 실험임.

#### 이번 실험에서 발견된 새 취약점

그러던 중 o3가 kerberos 인증 이외에 신규로 발견한 use-after-free 버그가 발견됨. 바로 세션의 logoff 핸들러에서, 두 스레드가 동시 연결 상태에서 세션의 user 객체를 공유/접속하면서 한 스레드가 객체를 해제한 후 다른 스레드가 이를 계속 참조할 수 있는 동시성 문제임.

##### o3의 취약점 자동 리포트 요약

* 두 개의 워커 스레드가 협동하여, 하나는 세션 해제(logoff) 수행 중 user 객체를 메모리에서 해제하고, 다른 하나는 기존 세션에서 그 user 객체를 계속 사용
* 해제 직후(아직 NULL로 초기화되기 전)에 또 다른 경로에서 dereference가 발생하면 classic use-after-free
* 타이밍에 따라 NULL dereference로 인한 DoS도 발생 가능
* 커널 메모리 손상 및 임의 코드 실행로 이어질 수 있음

#### 자동 보고서를 통해 얻은 인사이트

이 자동 리포트에서, 기존 kerberos 인증 취약점의 수정 방식이(해제 직후 NULL로 세팅) 로그오프 처리에서는 근본적 해결책이 아님을 깨달음. 즉, 세션 바인딩과 스레드간 공격 벡터를 고려해야 안전성이 보장됨. o3 역시 일부 보고서에서는 이 점을 간파하여 ‘더 강력한’ 수정책 제시가 가능함을 실증함.

결론
--

LLM, 특히 o3와 같은 최신 모델은 코드의 창의적·유연한 분석 면에서 기존 기법보다 **인간 보안 연구자에 훨씬 가까운 성능**을 보여줌. 최근까지는 이론적으로 가능성이 거론되어 왔으나, 실제 사례에서 현실적으로 ‘도움이 되는 수준’에 도달한 것은 o3가 처음임. 물론 o3 역시 여전히 오탐·누락 가능성이 존재하나, **실제로 쓸모 있는 결과를 내놓을 가능성이 높아져 실무 투입이 의미 있는 시점**이 되었음. 이제 취약점 연구자나 개발자가 자신의 업무 플로우에 LLM을 효율적으로 결합하는 방법을 찾아야 할 타이밍임.

