# 코딩 에이전트 구축을 위해 LangGraph를 선택한 이유


* Qodo는 GPT-3 시절부터 AI 코딩 보조 도구를 개발해온 팀으로, 최근에는 더 유연하고 동적인 코딩 에이전트를 만들기 위해 LangGraph 프레임워크를 선택
* 이 문서는 LangGraph가 어떻게 개발 흐름의 유연성과 코드 품질 기준을 동시에 만족시킬 수 있었는지를 설명함

초기 구조적 접근 방식에서 LangGraph로의 전환
-----------------------------

* GPT-3 기반 초기에는 테스트 생성, 코드 리뷰, 개선 작업 등 명확한 흐름을 가진 구조적 작업이 중심이었음
* Claude Sonnet 3.5 이후 LLM의 성능이 크게 향상되며, 보다 동적인 에이전트 설계가 가능해짐
* 기존에는 정형화된 워크플로우만 가능했지만, 새로운 모델을 활용해 유저 요청에 유연하게 대응 가능한 시스템을 개발하려고 함
* 빠른 실험과 검증이 가능한 프레임워크를 찾는 과정에서 LangGraph를 선택하게 되었으며, 초기 개념 검증을 넘어서 실제 제품까지 확장 가능했음

유연성과 명확한 규칙의 공존
---------------

* LangGraph는 상태 기계(state machine)를 기반으로 한 그래프 구조를 제공함
* 각 노드는 워크플로우의 개별 단계(문맥 수집, 계획, 실행, 검증 등)를 담당하고, 간선(edge)은 단계 간 전이 규칙을 정의함
* 간선의 밀도에 따라 워크플로우의 유연성 또는 구조화 정도가 달라짐
  + 희소 그래프 → 고정적이고 예측 가능한 흐름
  + 조밀 그래프 → 동적인 흐름과 다양한 경로 선택 가능
* LangGraph의 장점은 모델이 발전함에 따라 워크플로우의 구조화 정도를 쉽게 재조정할 수 있다는 점임
* 주 흐름은 다음과 같은 구조임:
  + 문맥 수집 → 작업 계획 → 코드 실행 → 결과 검증 → 실패 시 반복

간결하고 직관적인 인터페이스
---------------

* LangGraph는 선언형으로 워크플로우를 정의할 수 있어 코드가 거의 문서처럼 읽힘
* 상태 그래프를 선언하고 노드와 간선을 추가하는 방식으로 동작
* 조건부 흐름도 쉽게 구현 가능 (예: 검증 실패 시 실행 노드로 루프)
* LangChain의 복잡한 추상화와 달리 LangGraph는 로직이 드러나는 구조로 개발자 경험이 좋음

다양한 워크플로우 간 재사용성
----------------

* 노드 기반 구조 덕분에 컴포넌트의 재사용이 쉬움
  + 예: 문맥 수집 노드와 검증 노드는 대부분의 플로우에서 반복 사용됨
* 새로운 특화된 흐름(TDD 등)을 만들 때도 기존 노드를 다시 연결하여 빠르게 확장 가능

기본 제공되는 상태 관리 기능
----------------

* LangGraph는 상태 저장 기능을 기본으로 제공하여 영속성 구현이 매우 간단함
  + 예: Postgres를 통한 체크포인팅 기능은 몇 줄의 코드로 설정 가능
* 수집된 문맥, 계획, 실행 결과 등 전체 상태를 저장 가능하며, 브랜치와 롤백 기능도 지원됨
* SQLite, 인메모리 등 다른 방식도 쉽게 교체 가능함

개선이 필요한 부분
----------

* 빠르게 발전 중인 프레임워크라 문서가 불완전하거나 업데이트가 늦는 경우가 있음
  + 다행히 슬랙을 통한 유지보수자들과의 소통은 빠르고 적극적이었음
* 비결정적 LLM 시스템의 테스트는 여전히 도전 과제임
  + IDE와 상호작용하는 에이전트의 경우 자동화된 테스트 환경 구현이 어려움
  + 일부 IDE 기능은 모킹하기 매우 어려워 수동 테스트에 의존해야 했고, 이는 반복 속도를 느리게 만들었음
* 성숙한 프레임워크는 테스트 및 모킹 인프라를 제공하는 경우가 많으며, LangGraph도 이러한 방향으로 발전하길 기대함
