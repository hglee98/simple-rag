# 내가 제일 좋아하는 프로그래밍 문법, "파이프라이닝"


* **파이프라이닝**은 프로그래밍 언어에서 코드의 가독성과 유지보수성을 높이는 중요한 기능임
* **데이터 흐름을 왼쪽에서 오른쪽, 위에서 아래로 자연스럽게** 표현할 수 있게 해주는 방식
* **Rust**와 같은 언어에서 파이프라이닝은 코드의 흐름을 명확하게 하고, **IDE**의 자동 완성 기능을 통해 개발 생산성을 높임
* Haskell, Elm, SQL 등 다양한 언어에서 적용되며, **builder 패턴**이나 **메서드 체이닝**도 일종의 파이프라이닝으로 간주
* **가독성**, **편집 편의성**, **IDE 지원**, **버전 관리 도구(diff, blame)** 에 모두 긍정적 영향
* 함수 중첩 방식보다 간결하고 명확한 코드를 작성할 수 있어 **협업과 유지보수 측면에서도 유리함**

---

내가 제일 좋아하는 프로그래밍 문법, 파이프라이닝
---------------------------

### 파이프라이닝이란?

* 이전 값을 전달하여 매개변수 목록에서 하나의 인수를 생략할 수 있는 기능
* 코드의 가독성을 높이고, 주석을 추가하기 쉽게 만들어 줌
* 데이터를 중심으로 **연속된 처리 작업을 순차적으로 적용**하는 문법 스타일
* 함수형 스타일 코드에서 `.map().filter().collect()` 같은 **메서드 체이닝** 형태로 많이 사용됨
* Rust에서 다음과 같은 코드가 대표적 예시:

  ```
  data.iter()  
      .filter(|w| w.alive)  
      .map(|w| w.id)  
      .collect()  

  ```
* 반대로 모든 함수를 중첩하면 다음처럼 **안에서 바깥으로 읽어야 하는 구조**가 됨:

  ```
  collect(map(filter(iter(data), |w| w.alive), |w| w.id))  

  ```

### 왜 파이프라이닝이 좋은가?

* 1. 가독성과 유지보수성
  -------------

  + 위에서 아래로 읽기 쉬움 → **사람이 읽는 순서와 동일한 데이터 흐름**
  + 각 줄에 **주석 달기 쉬움**
  + 긴 줄에 괄호 중첩 없이 **간결하고 명확**
* 2. 편집 편의성
  ---------

  + 중간에 `.map()` 등 새 함수를 **한 줄로 쉽게 추가** 가능
  + `git diff`나 `git blame`에서도 변경사항 추적이 깔끔하게 드러남
* 3. IDE / LSP 지원
  ---------------

  + `.` 키를 눌렀을 때 **자동완성 목록**이 뜨는 구조와 잘 맞음
  + 타입을 명확히 알고 있어야 가능한 정적 분석에 유리
  + 이 기능이 제대로 동작하려면 언어가 **정적 타입 기반**이어야 함 (e.g. Rust, TypeScript)

### SQL에도 파이프라이닝이?

* SQL의 중첩 SELECT 쿼리를 파이프라인 스타일로 바꿀 수 있다는 제안 존재
* 예시:

  ```
  FROM customer  
  |> LEFT OUTER JOIN orders ON ...  
  |> AGGREGATE COUNT(...) GROUP BY ...  
  |> ORDER BY ...  

  ```
* 기존 SQL보다 **명확한 흐름**, **가독성 향상**
* 단점: `SELECT` 구문이 위로 빠지면서 반환 타입 파악이 어려울 수 있음 → 해결 가능

### Builder 패턴과의 연계

* Rust의 `Builder::new().option().option().build()` 같은 형태는 전형적인 파이프라인 구조
* 선택적 설정을 메서드로 구성하면서 **코드 추적, 변경 관리가 용이**

### Haskell의 파이프라이닝 개선

* Haskell의 `$`, `&`, `|>` 같은 연산자는 **함수 합성 대신 파이프라인 사용을 가능하게 함**
* 예시 전후 비교:

  ```
  -- 기존  
  checkPalindromes content = unlines $ map (show . isPalindrome) $ lines $ map toLower content  

  -- 개선  
  checkPalindromes content =  
    content  
      & map toLower  
      & lines  
      & map (show . isPalindrome)  
      & unlines  

  ```

### Rust에서 파이프라이닝의 장점

* **메서드 체이닝**, **타입 추론**, **trait 기반의 구조적 확장성**이 모두 파이프라이닝과 잘 어우러짐
* Rust는 **함수형과 객체지향 문법의 장점만 뽑아낸 듯한 구조**로, 파이프라이닝 사용이 가장 자연스러움

### 결론

* 파이프라이닝은 단순한 문법이 아니라 **코드 흐름, 편집성, 협업까지 영향을 주는 핵심 기능**
* `f(g(h(x)))` 같은 중첩 대신 `x |> h |> g |> f` 구조가 더 **인간 친화적**
* 파이프라이닝은 "한 줄에 하나의 작업"이라는 단순한 규칙 아래, **자연스러운 흐름을 표현할 수 있는 최고의 방법**

> **“각 파이프 조각은 주요 데이터를 받아 한 가지 작업을 수행한다. 마지막에는 명확한 이름을 붙여주면 그게 가장 이상적인 코드 구조다.”**

