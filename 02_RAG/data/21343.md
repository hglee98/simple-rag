# 저수준 최적화와 Zig


* **저수준 최적화**는 Zig 언어에서 손쉽게 구현할 수 있음
* **컴파일러**가 대부분 상황에서 최적화를 잘 수행하지만, 때로는 프로그래머의 의도를 명확히 전달해야 더 나은 성능을 얻을 수 있음
* Zig는 **컴파일 타임 실행(comptime)** 기능으로 고성능 코드 생성과 강력한 메타프로그래밍을 지원함
* **러스트**와 비교할 때, Zig는 어노테이션과 명시적인 코드 구조로 더 정밀한 최적화 가능
* **문자열 비교** 등 반복적인 연산에서 comptime을 활용해 평범한 함수보다 뛰어난 어셈블리 코드 생성 가능

---

최적화와 Zig
--------

"모든 것이 가능하지만 흥미로운 것은 쉽게 얻을 수 없다."라는 유명한 경고처럼, **프로그램의 최적화**는 언제나 개발자의 주요 관심사임. 클라우드 인프라의 비용, 레이턴시 개선, 시스템 단순화 등을 위해 **코드 최적화**가 반드시 필요함. 이 글에서는 Zig에서의 저수준 최적화 개념과 Zig의 강점을 중점적으로 설명함.

컴파일러를 신뢰할 수 있을까?
----------------

* 일반적으로 "컴파일러를 신뢰하라"는 조언이 많으나, 실제로는 **컴파일러가 기대와 다르게 동작**하거나 언어 사양을 위반하는 경우가 있음
* 고수준 언어는 **의도(intent)** 를 명확히 전달하기 어렵기 때문에 성능상의 제약이 따름
* 저수준 언어는 코드의 **명시성** 때문에 컴파일러가 최적화에 필요한 정보를 알 수 있으며, 예로 JavaScript와 Zig의 maxArray 함수를 비교하면 Zig가 명확한 타입, 정렬, alias 여부 등을 런타임이 아닌 컴파일 타임에 전달함
* 동일한 maxArray 연산을 Zig와 Rust로 작성하면 거의 동일한 고성능 어셈블리 코드를 얻게 되지만, **의도를 더 잘 표현할수록 최적화 결과가 향상**됨
* 하지만 항상 컴파일러 성능을 신뢰할 수 없으므로, 병목 구간에서는 **코드와 컴파일 결괏값을 직접 확인**하고 최적화 방법을 모색해야 함

Zig의 역할
-------

* Zig는 **정확한 명시성**과 풍부한 내장 함수, 포인터와 어노테이션, comptime, 잘 정의된 Illegal Behavior 등의 특성으로 인해 **추상적인 정보 없이도 최적화된 코드**를 만들 수 있음
* Rust는 메모리 모델 덕분에 기본적으로 인자 alias가 없음이 보장되지만, Zig에서는 직접 **noalias 등 어노테이션 필요**
* 만약 LLVM IR만을 기준으로 한다면 Zig의 최적화 수준도 높음
* 무엇보다 Zig의 **comptime(컴파일 타임 실행)** 이 강력한 최적화 도구임

comptime이란 무엇인가?
----------------

* Zig의 **comptime**은 코드 생성, 상수 값 임베딩, 타입 기반 제네릭 구조체 생성 등에 활용되며, 런타임 성능 향상에 중요한 역할을 함
* comptime으로 **메타프로그래밍**을 구현할 수 있음
* C/C++의 매크로나 Rust의 macro 시스템과 달리, comptime은 별도의 문법이 아닌 **일반 코드**임
* comptime 코드는 AST를 직접 변경하지 않고, 모든 타입에 대해 컴파일 타임에 검사, 반영, 생성 가능함
* comptime의 유연성은 Rust 등 여타 언어 개선에도 영향을 미쳤으며, 자연스럽게 Zig 언어에 통합되어 있음

comptime의 한계
------------

* token-pasting과 같은 **일부 macro 기능**은 Zig comptime으로 대체 불가
* Zig는 코드의 **가독성을 중시**하기 때문에 범위를 벗어나서 변수 생성이나 매크로 정의 등은 허용하지 않음
* 대신 Zig comptime은 **타입 리플렉션**, DSL 구현, 문자열 파싱 최적화 등 폭넓은 메타프로그래밍 활용 예시가 존재함

comptime을 활용한 문자열 비교 최적화
------------------------

* 일반적인 문자열 비교 함수를 모든 언어에서 구현할 수 있으나, Zig에서 두 문자열 중 하나가 **comptime에 알려진 상수**일 때 더 효율적인 어셈블리 코드 생성 가능
* 예를 들어, 한 문자열이 늘 "Hello!\n"이라면 이 값을 바이트 단위가 아닌, **더 큰 블록 단위로 비교**하는 식의 최적화 활용 가능
* 이를 위해 comptime을 사용하면, **SIMD 벡터**, 블록 처리, 잔여 바이트 최적화 등 고성능 코드를 컴파일 타임에 생성 가능
* 이런 방식을 통해 반복적인 문자열 비교뿐 아니라, **정적 데이터 기반 다양한 맵핑, 완벽 해시 테이블, AST 파서 등** 다양한 성능중심 코드 구현 가능

결론
--

* **Zig는 저수준 최적화**에 매우 적합하며, 명시적 코드 구조와 강력한 comptime 기능 덕분에 최고의 성능을 직접 구현할 수 있음
* Rust 등 다른 언어와 비교해도, Zig의 컴파일 타임 프로그래밍 능력과 명시성은 고성능 소프트웨어 개발에 큰 이점으로 작용함
* Zig의 최적화 능력은 앞으로도 더욱 중요한 경쟁력이 될 것임
