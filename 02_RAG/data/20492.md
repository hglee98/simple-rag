# Go의 Reaper를 속이기


* Go 언어는 **정의되지 않은 동작**이 거의 없고, **간단한 GC(가비지 컬렉션) 의미론**을 가지고 있음
* Go 에서는 **수동 메모리 관리**가 가능하며, 이는 GC와 협력하여 수행할 수 있음
* **Arena**는 동일한 수명을 가진 메모리를 효율적으로 할당하는 데이터 구조로, Go에서 이를 구현하는 방법을 설명함
* **Mark and Sweep** 알고리듬을 통해 GC가 메모리를 관리하는 방법을 설명함
* Arena를 사용하여 **메모리 할당 성능**을 개선할 수 있으며, 이는 다양한 최적화를 통해 가능함
* **Write barrier 제거, 메모리 재사용, chunk pooling** 등을 통해 성능 향상 및 GC 부담 최소화 시도
* **Realloc 구현, Arena 재사용 및 초기화(Reset)** 기능 등을 통한 실제 대규모 메모리 처리 시의 안전하고 빠른 패턴 제시

---

Go에서 Arena 기반 수동 메모리 할당의 개요
---------------------------

* Go는 **명확한 GC 동작**과 **거의 없는 Undefined Behavior** 덕분에 안전한 언어임
* `unsafe` 패키지를 활용해 **GC의 내부 구현에 맞춘 메모리 직접 제어**가 가능함
* 이 글은 Go에서 GC와 협력 가능한 **Arena 구조 기반 메모리 할당기**를 만드는 방법을 설명함

Arena의 정의와 필요성
--------------

* Arena는 **같은 수명의 객체를 효율적으로 할당**하기 위한 구조
* 일반적인 `append`가 **지수적으로 배열을 확장**하는 방식이라면, Arena는 **새로운 블록을 추가하고 포인터를 제공**함
* 표준 인터페이스는 다음과 같음:
  + `Alloc(size, align uintptr) unsafe.Pointer`

포인터와 GC의 작동 방식
--------------

* GC는 \*\*메모리를 추적(mark)하고 회수(sweep)\*\*하는 방식으로 동작
* **정확한 GC**를 위해 포인터 위치 정보를 알려주는 **pointer bits**라는 메타데이터 사용
* Arena에서 포인터를 잘못 다루면, GC가 포인터를 추적하지 못해 **Use-After-Free 오류 발생 가능**

Arena 설계 방법
-----------

* Arena 구조는 다음과 같은 필드를 가짐:
  + `next`, `left`, `cap`, `chunks`
* 모든 할당은 8바이트 정렬로 처리하고, 부족하면 `nextPow2`로 새로운 chunk 생성
* chunk는 `[]uintptr` 대신 `struct { A [N]uintptr; P *Arena }` 타입으로 할당되어, **GC가 Arena를 추적 가능하게 함**

Arena의 포인터 안전성 확보 방법
--------------------

* Arena 내부에서만 할당된 포인터를 사용하는 경우 **GC가 Arena 전체를 유지시킴**
* 포인터가 Arena를 참조하도록 설정해 **Arena 전체가 GC에서 생존 보장됨**
* Arena의 할당 메서드는 다음을 수행함:
  + `allocChunk()`에서 Arena 포인터를 chunk의 마지막에 저장

성능 벤치마크 결과
----------

* 기본 `new` 대비 Arena 할당은 평균 **2~4배 이상의 성능 향상**을 보임
* GC 부하가 큰 상황에서도 Arena 방식이 최대 **2배 이상 우수한 성능**을 보임
* Write barrier 제거, `uintptr` 활용 등의 최적화는 **작은 할당에서 최대 20% 성능 향상**

Chunk 재사용 및 Heap 제거 전략
----------------------

* `sync.Pool`을 활용해 chunk 재사용 가능
* `runtime.SetFinalizer()`를 통해 Arena가 사라질 때 chunk를 pool에 반환
* 성능은 작은 할당에서 매우 좋아지지만, 큰 할당에서는 `new`보다 느려질 수 있음

Arena 초기화 및 재사용 기능
------------------

* `Reset()` 메서드로 Arena를 초기 상태로 되돌릴 수 있음
* 위험성이 크지만, 메모리 재할당 없이 동일 구조 재사용 가능
* 재사용 시에도 chunk 재사용하여 성능 대폭 향상됨

Realloc 기능 구현
-------------

* Arena에서 `realloc` 기능을 구현하여 가장 최근 할당에 대해 **동적 확장 가능**
* 불가능한 경우 새로운 메모리를 할당 후 복사 처리

결론 및 전체 코드 제공
-------------

* Go의 GC 메커니즘을 깊이 이해하고, 내부 구현에 기반해 **Arena 기반 메모리 관리기**를 완성
* 안전성과 성능을 모두 갖춘 구조이며, 적절히 사용하면 대규모 데이터 구조 처리에 매우 유용함
* 전체 구현 코드는 Arena 구조체와 `New`, `Alloc`, `Reset`, `allocChunk`, `finalize` 등을 포함
